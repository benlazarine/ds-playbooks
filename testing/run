#!/bin/bash

readonly ExecName=$(basename "$0")


show_help()
{
  cat <<EOF

$ExecName

Usage:
  $ExecName [options] <playbook_folder>

test Data Store playbooks

Parameters:
  <playbook_folder>  the path to the root directory for a collection of
                     playbooks

Options:
  -I, --inventory <inventory>  the name of the inventory to use
  -p, --playbook  <playbook>   the path to the playbook to test relative to
                               <playbook_folder>.

  -h, --help     show help and exit
  -i, --inspect  after running the playbook, open shell that allows manual
                 inspection of the configuration files, vaults, and logs
  -P, --pretty   more information will be output and newlines will be expanded
                 in that output.

Summary:
This script runs a playbook with in the testing environment. If no invetory is
provided, it will use the 'default' inventory. If no playbook is provided, it 
will attempt to run the playbook <playbook_folder>/main.yml.
EOF
}


readonly ExecName=$(readlink --canonicalize "$0")
readonly BaseDir=$(dirname "$ExecName")
readonly Cfg="$BaseDir"/config.inc
readonly DefaultInventory=default
readonly DefaultPlaybook=main.yml


main()
{
  local doInspect=false
  local inventory="$DefaultInventory"
  local pretty=false

  local opts
  opts=$(parse_cmd_line "$@")
  eval set -- "$opts"

  while true
  do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -I|--inventory)
        inventory="$2"
        shift 2
        ;;
      -i|--inspect)
        doInspect=true
        shift
        ;;
      -P|--pretty)
        pretty=true
        shift
        ;;
      -p|--playbook)
        local playbookInput="$2"
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
        exit_with_help
        ;;
    esac
  done

  if [ "$#" -lt 1 ]
  then
    exit_with_help
  fi

  local playbooks
  playbooks=$(resolve_playbook_dir "$1")

  local playbook
  playbook=$(resolve_playbook "$playbooks" "$playbookInput")

  do_run "$doInspect" "$pretty" "$playbooks" "$playbook" "$inventory"
}


do_run()
{
  local doInspect="$1"
  local pretty="$2"
  local playbooks="$3"
  local playbook="$4"
  local inventory="$5"

  if "$BaseDir"/env/controller "$Cfg" start
  then
    "$BaseDir"/ansible-tester/run "$doInspect" "$pretty" "$playbooks" "$playbook" "$inventory"
  fi

  "$BaseDir"/env/controller "$Cfg" stop
}


exit_with_help()
{
  show_help >&2
  exit 1
}


parse_cmd_line()
{
  local opts
  opts=$(getopt --longoptions help,inspect,inventory:,playbook:,pretty \
                --options hiI:p:P \
                --name "$ExecName" \
                -- \
                "$@")
  local ret="$?"

  if [ "$ret" -ne 0 ]
  then
    exit_with_help
  fi

  printf '%s' "$opts"
}


resolve_playbook()
{
  local playbooks="$1"
  local playbook="$2"

  : "${playbook:=$DefaultPlaybook}"

  if [[ "$playbook" != *.* ]]
  then
    playbook="$playbook".yml
  fi

  if ! [ -f "$playbooks"/"$playbook" ]
  then
    printf 'The playbook %s/%s does not exist\n' "$playbooks" "$playbook" >&2
    exit 1
  fi

  printf '%s' "$playbook"
}


resolve_playbook_dir()
{
  local playbooks="$1"

  if ! [[ "$playbooks" =~ ^/ ]]
  then
    playbooks="$(pwd)"/"$playbooks"
  fi

  if ! [ -d "$playbooks" ]
  then
    printf '%s is not a directory\n' "$playbooks" >&2
    exit 1
  fi

  printf '%s' "$playbooks"
}


set -e

# shellcheck source=config.inc
. "$Cfg"

main "$@"
